import { Device } from './Device';
const evdev = require('../../build/Release/nevdev.node');

interface UInputOptions {
  name?: string;
}
export class UInput {
  private _name: string;

  /**
   * Create a uinput device based on the given libevdev device. The uinput device
   * will be an exact copy of the libevdev device, minus the bits that uinput doesn't
   * allow to be set.
   *
   * If uinput_fd is @ref LIBEVDEV_UINPUT_OPEN_MANAGED, libevdev_uinput_create_from_device()
   * will open @c /dev/uinput in read/write mode and manage the file descriptor.
   * Otherwise, uinput_fd must be opened by the caller and opened with the
   * appropriate permissions.
   *
   * The device's lifetime is tied to the uinput file descriptor, closing it will
   * destroy the uinput device. You should call libevdev_uinput_destroy() before
   * closing the file descriptor to free allocated resources.
   * A file descriptor can only create one uinput device at a time; the second device
   * will fail with -EINVAL.
   *
   * You don't need to keep the file descriptor variable around,
   * libevdev_uinput_get_fd() will return it when needed.
   *
   * @note Due to limitations in the uinput kernel module, REP_DELAY and
   * REP_PERIOD will default to the kernel defaults, not to the ones set in the
   * source device.
   *
   * @note On FreeBSD, if the UI_GET_SYSNAME ioctl() fails, there is no other way
   * to get a device, and the function call will fail.
   *
   * @param {Device} dev The device to duplicate
   *
   * @return 0 on success or a negative errno on failure. On failure, the value of
   * uinput_dev is unmodified.
   *
   * @see libevdev_uinput_destroy
   */

  static createFromDevice(device: Device): UInput {}

  constructor(options: UInputOptions) {
    this._name = options.name;

    const dev = evdev.libevdev_new();
    evdev.libevdev_set_name(dev, this._name);
    evdev.libevdev_enable_event_type(dev, EV_REL);
    evdev.libevdev_enable_event_code(dev, EV_REL, REL_X, NULL);
    evdev.libevdev_enable_event_code(dev, EV_REL, REL_Y, NULL);
    evdev.libevdev_enable_event_type(dev, EV_KEY);
    evdev.libevdev_enable_event_code(dev, EV_KEY, KEY_1, NULL);
    evdev.libevdev_enable_event_code(dev, EV_KEY, KEY_2, NULL);
    evdev.libevdev_enable_event_code(dev, EV_KEY, KEY_3, NULL);
    evdev.libevdev_enable_event_code(dev, EV_KEY, KEY_4, NULL);
    evdev.libevdev_enable_event_code(dev, EV_KEY, KEY_5, NULL);
    evdev.libevdev_enable_event_code(dev, EV_KEY, BTN_LEFT, NULL);
    evdev.libevdev_enable_event_code(dev, EV_KEY, BTN_MIDDLE, NULL);
    evdev.libevdev_enable_event_code(dev, EV_KEY, BTN_RIGHT, NULL);

    // err = libevdev_uinput_create_from_device(dev,
    //                                        LIBEVDEV_UINPUT_OPEN_MANAGED,
    //                                        &uidev);
  }
  destroy(): void {}
  /**
   * @ingroup uinput
   *
   * Post an event through the uinput device. It is the caller's responsibility
   * that any event sequence is terminated with an EV_SYN/SYN_REPORT/0 event.
   * Otherwise, listeners on the device node will not see the events until the
   * next EV_SYN event is posted.
   *
   * @param uinput_dev A previously created uinput device.
   * @param type Event type (EV_ABS, EV_REL, etc.)
   * @param code Event code (ABS_X, REL_Y, etc.)
   * @param value The event value
   * @return 0 on success or a negative errno on error
   */
  writeEvent(): void {}

  /**
   * Return the syspath representing this uinput device. If the UI_GET_SYSNAME
   * ioctl not available, libevdev makes an educated guess.
   * The UI_GET_SYSNAME ioctl is available since Linux 3.15.
   *
   * The syspath returned is the one of the input node itself
   * (e.g. /sys/devices/virtual/input/input123), not the syspath of the device
   * node returned with libevdev_uinput_get_devnode().
   *
   * @note This function may return NULL if UI_GET_SYSNAME is not available.
   * In that case, libevdev uses ctime and the device name to guess devices.
   * To avoid false positives, wait at least wait at least 1.5s between
   * creating devices that have the same name.
   *
   * @note FreeBSD does not have sysfs, on FreeBSD this function always returns
   * NULL.
   *
   * @return The syspath for this device, including the preceding /sys
   *
   * @see libevdev_uinput_get_devnode
   */
  getSyspath(): number {}
  /**
   * @ingroup uinput
   *
   * Return the device node representing this uinput device.
   *
   * This relies on libevdev_uinput_get_syspath() to provide a valid syspath.
   * See libevdev_uinput_get_syspath() for more details.
   *
   * @note This function may return NULL. libevdev may have to guess the
   * syspath and the device node. See libevdev_uinput_get_syspath() for details.
   *
   * @note On FreeBSD, this function can not return NULL.  libudev uses the
   * UI_GET_SYSNAME ioctl to get the device node on this platform and if that
   * fails, the call to libevdev_uinput_create_from_device() fails.
   *
   * @return The device node for this device, in the form of /dev/input/eventN
   *
   * @see libevdev_uinput_get_syspath
   */
  getDevnode(): number {}
  /**
   * Return the file descriptor used to create this uinput device. This is the
   * fd pointing to <strong>/dev/uinput</strong>. This file descriptor may be used to write
   * events that are emitted by the uinput device.
   * Closing this file descriptor will destroy the uinput device, you should
   * call libevdev_uinput_destroy() first to free allocated resources.
   *
   * @param uinput_dev A previously created uinput device.
   *
   * @return The file descriptor used to create this device
   */
  getFd(): number {}
}
